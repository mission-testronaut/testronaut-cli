// Keep browsers in project-local cache; matches ensureBrowsers()
process.env.PLAYWRIGHT_BROWSERS_PATH = process.env.PLAYWRIGHT_BROWSERS_PATH || '0';

// import { chromium } from 'playwright';
import { createRequire } from 'module';
const req = createRequire(process.cwd() + '/noop.js'); // resolve from user project
async function loadPlaywright() {
  try { return req('playwright'); } catch {}
  try { return req('@playwright/test'); } catch {}
  try { return req('playwright-core'); } catch {}
  throw new Error('Playwright is not installed in this project. Run: npm i -D @playwright/test');
}
import * as cheerio from 'cheerio';
import { 
  chunkBySection, 
  reduceRepeatedDivs, 
  removeAutoGeneratedClasses, 
  removeNonContentTags,
  removeObfuscatedClassNames, 
} from './domControl.js';
import fs from 'fs';
import path from 'path';
import { ensureBrowsers } from '../tools/playwrightSetup.js';

const FILES_DIR = path.join('missions', 'files');
const REPORTS_DIR = path.join('missions', 'mission_reports');
const FILES_LOG = path.join(REPORTS_DIR, 'files.jsonl');

function ensureDir(p) {
  try { fs.mkdirSync(p, { recursive: true }); } catch {}
}

function appendFileEvent(eventObj = {}) {
  try {
    ensureDir(REPORTS_DIR);
    fs.appendFileSync(FILES_LOG, JSON.stringify(eventObj) + '\n', 'utf8');
  } catch (e) {
    console.warn('⚠️ Could not append file event:', e?.message);
  }
}

export class ChromeBrowser {
  constructor() {
    this.browser = null;
    this.context = null;
    this.page = null;

    // simple registry
    this.pages = [];      // [{ id, page }]
    this.currentId = '';  // page id we currently control
  }

  _makePageId(page) {
    // playwright's Page has a non-public guid in TS; fallback to random
    return `p_${Math.random().toString(36).slice(2)}`;
  }
  _getCurrent() {
    const cur = this.pages.find(p => p.id === this.currentId) ?? this.pages[this.pages.length - 1];
    if (!cur) throw new Error('No active page in registry');
    return cur;
  }
  _addAndFocus(page) {
    const id = this._makePageId(page);
    this.pages.push({ id, page });
    this.currentId = id;
    this.page = page;

    page.on('close', () => {
      // remove from registry
      this.pages = this.pages.filter(p => p.id !== id);
      // if we just lost the active page, pick a reasonable fallback
      if (this.currentId === id) {
        this.currentId = this.pages[this.pages.length - 1]?.id
                      ?? this.pages[0]?.id
                      ?? '';
        this.page = this.currentId
          ? this.pages.find(p => p.id === this.currentId).page
          : null;
      }
    });

    return id;
  }

  _switchTo(target) {
    if (target === 'main') {
      this.currentId = this.pages[0]?.id ?? '';
    } else if (target === 'latest') {
      this.currentId = this.pages[this.pages.length - 1]?.id ?? '';
    } else {
      const found = this.pages.find(p => p.id === target);
      if (!found) throw new Error(`No page with id "${target}"`);
      this.currentId = found.id;
    }
    const cur = this._getCurrent();
    this.page = cur.page; // keep legacy this.page in sync
    return this.currentId;
  }

    // ---- helpers: retries, wait, and locator resolution ----
  async _withRetries(fn, { attempts = 3, baseMs = 250 } = {}) {
    let lastErr;
    for (let i = 0; i < attempts; i++) {
      try {
        return await fn();
      } catch (err) {
        lastErr = err;
        // Exponential backoff: 250ms, 500ms, 1000ms...
        await this.page.waitForTimeout(baseMs * Math.pow(2, i));
      }
    }
    throw lastErr;
  }

  async _waitReadyForInteract(locator, { timeout = 3000 } = {}) {
    // “Visible & enabled” is the sweet spot for flake reduction
    await locator.first().waitFor({ state: 'visible', timeout });
    // Extra: ensure it’s not disabled/covered
    await locator.first().scrollIntoViewIfNeeded().catch(() => {});
  }

  _resolveLocator(selectorOrFn, fallbacks = []) {
    // Accept: string CSS/XPath via page.locator, or a function (page) => Locator
    const candidates = [
      selectorOrFn,
      ...fallbacks,
    ].filter(Boolean);

    const locators = candidates.map(c => {
      if (typeof c === 'function') return c(this.page).first();
      if (typeof c === 'string')  return this.page.locator(c).first();
      // Unsupported type → ignore
      return null;
    }).filter(Boolean);

    return locators;
  }

  // Generic frame access
  _allFrames({ includeMain = true } = {}) {
    const frames = this.page.frames();
    if (includeMain) {
      const main = this.page.mainFrame();
      return [main, ...frames.filter(f => f !== main)];
    }
    return frames;
  }

  // Build candidate locator MAKERS (Page|Frame-aware)
  _buildClickCandidates({ selector, text, role, attrs, scope, searchAllFrames }) {
    const frames = searchAllFrames ? this._allFrames({ includeMain: true }) : [this.page.mainFrame()];
    const makers = [];
    const add = (fn) => fn && makers.push(fn);

    for (const f of frames) {
      const ctx = f; // <-- IMPORTANT: use Frame directly (or this.page for main)

      const locInScope = (loc) => (scope ? ctx.locator(scope).locator(loc) : ctx.locator(loc));

      // 1) Explicit selector/function first
      if (selector) {
        add(() => typeof selector === 'function' ? selector(ctx).first() : locInScope(selector).first());
      }

      // 2) Hints (all generic)
      if (role && text) add(() => ctx.getByRole(role, { name: text }).first());
      if (role && !text) add(() => ctx.getByRole(role).first());
      if (text && !role) {
        add(() => ctx.getByRole('button', { name: text }).first());
        add(() => ctx.getByRole('link',   { name: text }).first());
        add(() => ctx.getByText(text).locator('..').locator('button, a, [role="button"]').first());
      }
      if (attrs && Object.keys(attrs).length) {
        const attrSel = Object.entries(attrs)
          .map(([k,v]) => v === true ? `[${k}]` : `[${k}="${String(v)}"]`)
          .join('');
        if (attrSel) add(() => locInScope(attrSel).first());
      }
    }

    const seen = new Set();
    return makers.filter(fn => { const k = fn.toString(); if (seen.has(k)) return false; seen.add(k); return true; });
  }


  // Clickability check (visible, enabled, hit-testable)
  async _isClickable(locator) {
    try {
      const vis = await locator.isVisible();
      if (!vis) return false;
      const [enabled, pe, display, visibility, bbox] = await Promise.all([
        locator.isEnabled().catch(() => false),
        locator.evaluate(el => getComputedStyle(el).pointerEvents).catch(() => 'auto'),
        locator.evaluate(el => getComputedStyle(el).display).catch(() => 'block'),
        locator.evaluate(el => getComputedStyle(el).visibility).catch(() => 'visible'),
        locator.boundingBox().catch(() => null),
      ]);
      if (!enabled) return false;
      if (pe === 'none' || display === 'none' || visibility === 'hidden') return false;
      if (!bbox || bbox.width < 1 || bbox.height < 1) return false;
      return true;
    } catch { return false; }
  }

  async _withRetries(fn, { attempts = 3, baseMs = 250 } = {}) {
    let lastErr;
    for (let i = 0; i < attempts; i++) {
      try { return await fn(); }
      catch (err) {
        lastErr = err;
        await this.page.waitForTimeout(baseMs * Math.pow(2, i));
      }
    }
    throw lastErr;
  }

  // Resolve a locator from string or function (page)=>Locator
  _resolveAny(selectorOrFn, { page = this.page }) {
    if (!selectorOrFn) return null;
    return typeof selectorOrFn === 'function'
      ? selectorOrFn(page).first()
      : page.locator(String(selectorOrFn)).first();
  }

  // Wait for a single condition
  async _waitOne(cond, { timeout = 8000, searchAllFrames = false } = {}) {
    const page = this.page;
    const frames = searchAllFrames ? [page.mainFrame(), ...page.frames().filter(f => f !== page.mainFrame())] : [page.mainFrame()];
    const start = Date.now();

    const left = () => Math.max(0, timeout - (Date.now() - start));

    // URL-based
    if (cond.urlIncludes) {
      const re = cond.urlIncludes instanceof RegExp ? cond.urlIncludes : new RegExp(cond.urlIncludes.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      return page.waitForURL(u => re.test(String(u)), { timeout: left() });
    }
    if (cond.urlExcludes) {
      const re = cond.urlExcludes instanceof RegExp ? cond.urlExcludes : new RegExp(cond.urlExcludes.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      return page.waitForURL(u => !re.test(String(u)), { timeout: left() });
    }
    if (cond.urlMatches) {
      return page.waitForURL(cond.urlMatches, { timeout: left() });
    }
    if (cond.urlChangedFrom) {
      const prev = cond.urlChangedFrom;
      return page.waitForURL(u => String(u) !== String(prev), { timeout: left() });
    }

    // Function predicate
    if (cond.predicate) {
      return page.waitForFunction(cond.predicate, null, { timeout: left(), polling: 100 });
    }

    // Visibility/attachment on any frame
    const stateMap = {
      visible: 'visible',
      hidden: 'hidden',
      attached: 'attached',
      detached: 'detached',
    };
    for (const key of Object.keys(stateMap)) {
      if (cond[key]) {
        const state = stateMap[key];
        for (const f of frames) {
          const p = f.page ? f.page() : page;
          const loc = this._resolveAny(cond[key], { page: p });
          if (!loc) continue;
          try { await loc.waitFor({ state, timeout: left() }); return; } catch {/* try next frame */ }
        }
        // If we didn’t return from a frame, throw to trigger retry chain
        throw new Error(`Timeout waiting for ${key}`);
      }
    }

    // Fallback: no-op
    return;
  }

  // Wait for composite conditions
  async _waitUntil({ all = [], any = [], timeoutMs = 8000, searchAllFrames = false } = {}) {
    if (!all.length && !any.length) return;

    const deadline = Date.now() + timeoutMs;

    // ALL: run sequentially (each with shared remainder timeout)
    for (const c of all) {
      const left = Math.max(0, deadline - Date.now());
      await this._waitOne(c, { timeout: left, searchAllFrames });
    }

    // ANY: race the remaining time
    if (any.length) {
      const left = Math.max(0, deadline - Date.now());
      await Promise.any(any.map(c => this._waitOne(c, { timeout: left, searchAllFrames })));
    }
  }

  // Heuristics (override per call if you want)
  DEFAULT_TRANSIENT_URL_RE = /(loading|redirect|callback|auth|sso|processing)/i;
  DEFAULT_LOADER_SELECTORS = [
    '[aria-busy="true"]',
    '[role="progressbar"]',
    '[aria-live="polite"][role="status"]',
    '.loading,.loader,.spinner,.progress,.skeleton,.backdrop,.overlay',
    '[data-loading="true"]',
    '[data-busy="true"]',
    '[data-state="loading"]',
  ];

  _allFrames({ includeMain = true } = {}) {
    const frames = this.page.frames();
    if (includeMain) {
      const main = this.page.mainFrame();
      return [main, ...frames.filter(f => f !== main)];
    }
    return frames;
  }

  async _frameHasVisible(frame, selector) {
    // Visible = attached & not display:none/visibility:hidden & has size
    return frame.evaluate((sel) => {
      const els = Array.from(document.querySelectorAll(sel));
      const isVisible = (el) => {
        const cs = getComputedStyle(el);
        if (cs.display === 'none' || cs.visibility === 'hidden' || cs.opacity === '0') return false;
        const r = el.getBoundingClientRect();
        return r.width > 0 && r.height > 0;
      };
      return els.some(isVisible);
    }, selector).catch(() => false);
  }

  /**
   * Wait until no loader selectors are visibly present across frames
   * for a continuous quiet window (quietMs). Generic & overrideable.
   */
  async _waitLoaderGone({
    selectors = this.DEFAULT_LOADER_SELECTORS,
    searchAllFrames = true,
    timeoutMs = 12000,
    quietMs = 700,
    pollMs = 120,
  } = {}) {
    const frames = searchAllFrames ? this._allFrames({ includeMain: true }) : [this.page.mainFrame()];
    const start = Date.now();
    let quietStart = 0;

    const joined = selectors.join(',');

    while (Date.now() - start < timeoutMs) {
      let visible = false;
      for (const f of frames) {
        const vis = await this._frameHasVisible(f, joined);
        if (vis) { visible = true; break; }
      }

      if (!visible) {
        if (quietStart === 0) quietStart = Date.now();
        if (Date.now() - quietStart >= quietMs) return; // success: no loader for quiet window
      } else {
        quietStart = 0; // reset quiet window
      }
      await this.page.waitForTimeout(pollMs);
    }
    // If timeout, let caller decide (don’t throw by default to keep tests moving)
    throw new Error('Loader still visible after timeout');
  }

  /**
   * Wait until the URL is past transient/bounce routes (e.g., loading/callback).
   * If you just want “leave current url”, pass urlChangedFrom = true.
   */
  async _waitPastTransientUrls({
    urlChangedFrom,                 // string | true
    transientUrlRe = this.DEFAULT_TRANSIENT_URL_RE,
    timeoutMs = 12000,
    quietMs = 400,                  // require the non-transient URL to stick briefly
  } = {}) {
    const page = this.page;
    const startUrl = urlChangedFrom === true ? page.url() : (urlChangedFrom || null);
    const start = Date.now();
    let stableStart = 0;

    while (Date.now() - start < timeoutMs) {
      const u = page.url();
      const leftStart = !startUrl || u !== String(startUrl);
      const notTransient = !transientUrlRe || !transientUrlRe.test(u);

      if (leftStart && notTransient) {
        if (stableStart === 0) stableStart = Date.now();
        if (Date.now() - stableStart >= quietMs) return; // success
      } else {
        stableStart = 0;
      }
      await this.page.waitForTimeout(100);
    }
    // Don’t throw; caller can decide to continue with other guards
    throw new Error('URL did not move past transient routes in time');
  }

  async _waitEnabled(locator, { timeoutMs = 2500, pollMs = 120 } = {}) {
    const start = Date.now();
    while (Date.now() - start < timeoutMs) {
      const enabled = await locator.isEnabled().catch(() => false);
      if (enabled) return true;
      await this.page.waitForTimeout(pollMs);
    }
    return false;
  }

  async _debugClickableSnapshot({ scope } = {}) {
    const frames = this._allFrames({ includeMain: true });
    const lines = [];
    for (const [i,f] of frames.entries()) {
      const ctx = f;
      const root = scope ? ctx.locator(scope) : ctx;
      const btns = await root.locator('button, [role="button"], a[href], input[type="submit"]').elementHandles();
      const snippets = await Promise.all(btns.slice(0, 10).map(h => h.evaluate(el => {
        const txt = (el.innerText || el.value || '').trim().slice(0,50);
        return `<${el.tagName.toLowerCase()}> ${txt}`;
      })));
      lines.push(`frame[${i}] url=${f.url()} candidates=${snippets.join(' | ')}`);
    }
    console.log('[debug] clickables\n' + lines.join('\n'));
  }

  // Build candidates for text entry (Page|Frame-aware)
  _buildFillCandidates({ selector, placeholder, role = 'textbox', attrs, scope, searchAllFrames }) {
    const frames = searchAllFrames ? this._allFrames({ includeMain: true }) : [this.page.mainFrame()];
    const makers = [];
    const add = (fn) => fn && makers.push(fn);

    for (const f of frames) {
      const ctx = f; // Frame
      const locInScope = (loc) => (scope ? ctx.locator(scope).locator(loc) : ctx.locator(loc));

      // 1) Explicit selector/function first
      if (selector) {
        add(() => typeof selector === 'function' ? selector(ctx).first() : locInScope(selector).first());
      }

      // 2) Placeholder hint (semantic)
      if (placeholder) {
        add(() => ctx.getByPlaceholder(placeholder).first());
        // common shapes if placeholder is on a different element than the input
        add(() => locInScope(`[placeholder]`).filter({ hasText: placeholder }).first());
      }

      // 3) Role hint (textbox covers input/textarea/contenteditable)
      if (role) {
        add(() => ctx.getByRole(role).first());
        if (placeholder) add(() => ctx.getByRole(role, { name: placeholder }).first());
      }

      // 4) Generic text-entry shapes
      add(() => locInScope('input[type="text"], input[type="search"], input:not([type]), textarea').first());
      add(() => locInScope('[contenteditable=""], [contenteditable="true"], [role="textbox"]').first());

      // 5) Attribute filters
      if (attrs && Object.keys(attrs).length) {
        const attrSel = Object.entries(attrs)
          .map(([k,v]) => v === true ? `[${k}]` : `[${k}="${String(v)}"]`)
          .join('');
        if (attrSel) add(() => locInScope(attrSel).first());
      }
    }

    // de-dup
    const seen = new Set();
    return makers.filter(fn => { const k = fn.toString(); if (seen.has(k)) return false; seen.add(k); return true; });
  }


  async _waitEditable(locator, { timeoutMs = 2500, pollMs = 120 } = {}) {
    const start = Date.now();
    while (Date.now() - start < timeoutMs) {
      if (await locator.isEditable().catch(() => false)) return true;
      await this.page.waitForTimeout(pollMs);
    }
    return false;
  }

  async _smartClearAndType(locator, text) {
    // Try native fill first (clears automatically on inputs/textarea/contenteditable)
    try {
      await locator.fill(text, { timeout: 3000 });
      return 'fill';
    } catch {}

    // Fallback: focus + select all + type
    try {
      await locator.focus({ timeout: 1500 }).catch(() => {});
      // Select all on mac/linux/windows
      await this.page.keyboard.down('Control').catch(()=>{});
      await this.page.keyboard.press('KeyA').catch(()=>{});
      await this.page.keyboard.up('Control').catch(()=>{});
      await this.page.keyboard.press('Backspace').catch(()=>{});
      await locator.type(text, { delay: 10, timeout: 4000 }); // human-ish typing helps some SPAs
      return 'type';
    } catch {}

    // Last resort: set value via JS + dispatch events
    try {
      await locator.evaluate((el, value) => {
        const isCE = el.isContentEditable || el.getAttribute('contenteditable') === '' || el.getAttribute('contenteditable') === 'true';
        if (isCE) {
          el.innerText = value;
          el.dispatchEvent(new InputEvent('input', { bubbles: true, composed: true }));
          el.dispatchEvent(new Event('change', { bubbles: true, composed: true }));
        } else {
          const proto = Object.getPrototypeOf(el);
          const desc = Object.getOwnPropertyDescriptor(proto, 'value');
          if (desc?.set) desc.set.call(el, value); else el.value = value;
          el.dispatchEvent(new InputEvent('input', { bubbles: true, composed: true }));
          el.dispatchEvent(new Event('change', { bubbles: true, composed: true }));
        }
      }, text);
      return 'js';
    } catch {}

    throw new Error('Could not input text with any strategy');
  }

  _chromiumLaunchArgsForCI() {
    const inCI = !!(process.env.CI || process.env.GITHUB_ACTIONS || process.env.TESTRONAUT_CI_CHROMIUM);
    return inCI ? ['--no-sandbox', '--disable-setuid-sandbox'] : [];
  }


  async start() {
    try {
      const pw = await loadPlaywright();
      const launchArgs = [
       '--disable-dev-shm-usage',
       '--disable-gpu',
       ...this._chromiumLaunchArgsForCI(),
     ];
      this.browser = await pw.chromium.launch({ 
        headless: true,
        args: launchArgs,
      });    
    } catch (err) {
      const msg = String(err?.message || err);
      const needsInstall =
        msg.includes('Executable doesn\'t exist') ||
        msg.includes('was just installed or updated') ||
        msg.includes('looks like Playwright') ||
        msg.includes('browserType.launch');

      if (!needsInstall) throw err;

      // Download the right browsers and retry once
      console.log('🧩 Playwright browsers missing or stale. Installing…');
      await ensureBrowsers({ browser: 'chromium', withDeps: true });

      // Retry
      const pw = await loadPlaywright();
      const launchArgs = [
        '--disable-dev-shm-usage',
        '--disable-gpu',
        ...this._chromiumLaunchArgsForCI(),
      ];
      this.browser = await pw.chromium.launch({
        headless: true,
        args: launchArgs,
      });
      // return await pw.chromium.launch({ headless: true });
    }

    ensureDir(FILES_DIR); // ⬅️ make sure missions/files exists

    this.context = await this.browser.newContext({
      acceptDownloads: true // ⬅️ important for Playwright download handling
    });
    // this.context = await this.browser.newContext();
    const first = await this.context.newPage();
    const id = this._addAndFocus(first);

    // optional: keep registry in sync if pages are closed elsewhere
    this.context.on('close', () => { this.pages = []; this.currentId = ''; });
    first.on('close', () => {
      this.pages = this.pages.filter(p => p.id !== id);
      if (this.currentId === id) {
        this.currentId = this.pages[this.pages.length - 1]?.id ?? this.pages[0]?.id ?? '';
        this.page = this._getCurrent()?.page ?? null;
      }
    });
    await first.addStyleTag({ content: `*{animation-duration:.001s!important;transition-duration:.001s!important}` }).catch(() => {});
  }

  async navigate({ url, loaderAware = true, loaderSelectors, transientUrlRe }) {
    await this.page.goto(url, { timeout: 30_000, waitUntil: 'domcontentloaded' });
    // Cheap global stabilization: make sure DOM is there & form container attached if present
    await this.page.waitForLoadState('domcontentloaded').catch(() => {});
    // If you expect a specific route like /sign-in, you can keep this generic and fast:
    // await this.page.waitForURL(/\/sign-in/).catch(() => {});
    // Defensive: ensure *something* form-like is attached (doesn't need to be visible)
    await this.page.locator('form').first().waitFor({ state: 'attached', timeout: 3000 }).catch(() => {});

    if (loaderAware) {
      try { await this._waitPastTransientUrls({ urlChangedFrom: url, transientUrlRe }); } catch {}
      try { await this._waitLoaderGone({ selectors: loaderSelectors }); } catch {}
    }
    return `navigated to ${this.page.url()}`;
  }


  /**
   * Generic fill with retries and broad textbox detection.
   * Accepts your existing { selector, text } and optional:
   * { placeholder, role, attrs, scope, searchAllFrames, strategy, loaderAware }
   */
  async fill({
    selector,
    text,
    placeholder,          // string | RegExp
    role = 'textbox',     // generic default
    attrs,
    scope,
    searchAllFrames = true,
    strategy = 'auto',    // 'strict' -> selector only
    loaderAware = true,   // if you added the loader helpers earlier
  }) {
    if (loaderAware) {
      // Best effort: avoid typing while loader overlays block focus
      try { await this._waitLoaderGone({ timeoutMs: 6000 }); } catch {}
    }

    const makeCandidates = () => {
      if (strategy === 'strict') {
        return this._buildFillCandidates({ selector, scope, searchAllFrames });
      }
      return this._buildFillCandidates({ selector, placeholder, role, attrs, scope, searchAllFrames });
    };

    return this._withRetries(async () => {
      const makers = makeCandidates();
      let chosen = null;

      // re-resolve each attempt (survive rerenders)
      for (const make of makers) {
        const loc = make(); if (!loc) continue;
        try {
          await loc.scrollIntoViewIfNeeded().catch(() => {});
          await loc.waitFor({ state: 'visible', timeout: 2000 });       // visible on screen
          const enabled = await this._waitEnabled(loc, { timeoutMs: 2500 });
          if (!enabled) continue;
          const editable = await this._waitEditable(loc, { timeoutMs: 2500 });
          if (!editable) continue;
          chosen = loc; break;
        } catch {
          // try next
        }
      }
      if (!chosen) {
        // quick debug snapshot (optional)
        // const html = await this.page.content(); fs.writeFileSync('debug_fill.html', html);
        throw new Error('No editable textbox became ready');
      }

      const method = await this._smartClearAndType(chosen, text);
      return `filled via ${method}`;
    }, { attempts: 3, baseMs: 250 });
  }



  /**
   * @param {object} opts
   * ...
   * @param {object}          [opts.until]        // declarative post-action waits
   * @param {Array<object>}   [opts.until.all]    // all must pass
   * @param {Array<object>}   [opts.until.any]    // any may pass
   * @param {number}          [opts.until.timeoutMs=8000]
   * @param {boolean}         [opts.until.searchAllFrames=true]
   * @param {boolean}         [opts.waitDomReady=true] // cheap settle
   * @param {number}          [opts.delayMs=200]       // micro settle
   */
  async click({
    selector, text, role, attrs, scope,
    searchAllFrames = true,
    strategy = 'auto',
    waitFor,   
    waitDomReady = true,
    delayMs = 200,
    until,
    loaderAware = true,               // NEW
    loaderSelectors,                  // NEW
    transientUrlRe,                   // NEW
    postClickTimeoutMs = 12000, 
  }) {
    const prevUrl = this.page.url();

    // Build your candidates the way you already do (generic/hint-driven)
    const makers = (strategy === 'strict')
      ? this._buildClickCandidates({ selector, scope, searchAllFrames })
      : this._buildClickCandidates({ selector, text, role, attrs, scope, searchAllFrames });

    // choose & click (same as your generic version)
    let chosen = null;
    for (const make of makers) {
      const loc = make(); if (!loc) continue;
      try {
        await loc.scrollIntoViewIfNeeded().catch(() => {});
        await loc.waitFor({ state: 'visible', timeout: 2000 });

        await loc.scrollIntoViewIfNeeded().catch(() => {});
        await loc.waitFor({ state: 'visible', timeout: 2000 });

        const becameEnabled = await this._waitEnabled(loc, { timeoutMs: 2500 });
        if (!becameEnabled) {
          // try next candidate; this one is still disabled after ~2.5s
          continue;
        }
        if (await this._isClickable(loc)) {
          chosen = loc;
          break;
        }

        if (await this._isClickable(loc)) { chosen = loc; break; }
      } catch {}
    }
    if (!chosen) {
      await this._debugClickableSnapshot({ scope }).catch(()=>{});
      await this.page.screenshot({ path: 'missions/mission_reports/screenshots/click_fail.png' }).catch(()=>{});
      throw new Error('No clickable locator became ready');
    }
    // do the click (standard → hover+click → JS click)
    try { await chosen.click({ timeout: 3000 }); }
    catch {
      try { await chosen.hover({ timeout: 1200 }).catch(()=>{}); await chosen.click({ timeout: 3000 }); }
      catch { await chosen.evaluate(el => el.click()); }
    }

    // cheap settle so screenshots don't catch mid-paint
    if (waitDomReady) await this.page.waitForLoadState('domcontentloaded', { timeout: 3000 }).catch(()=>{});
    if (delayMs) await this.page.waitForTimeout(delayMs);

    // --- Built-in stabilization for loader pages (generic) ---
    if (loaderAware) {
      const endBy = Date.now() + postClickTimeoutMs;

      // 1) Move past transient URLs (loading/callback/redirect/etc.)
      try {
        await this._waitPastTransientUrls({
          urlChangedFrom: true,
          transientUrlRe: transientUrlRe ?? this.DEFAULT_TRANSIENT_URL_RE,
          timeoutMs: Math.max(0, endBy - Date.now()),
        });
      } catch { /* best effort, don’t fail here */ }

      // 2) Wait for loaders to vanish for a quiet window
      try {
        await this._waitLoaderGone({
          selectors: loaderSelectors ?? this.DEFAULT_LOADER_SELECTORS,
          searchAllFrames: true,
          timeoutMs: Math.max(0, endBy - Date.now()),
          quietMs: 700,
        });
      } catch { /* best effort, don’t fail here */ }
    }

    // 3) Your explicit declarative conditions (optional)


    // declarative postconditions (e.g., loader disappears, route changes, dashboard visible)
    if (until) {
      // convenience: if they asked for urlChange without specifying from, use prevUrl
      const normalized = {
        ...until,
        all: (until.all || []).map(c => c.urlChangedFrom === true ? { urlChangedFrom: prevUrl } : c),
      };
      await this._waitUntil({
        all: normalized.all || [],
        any: normalized.any || [],
        timeoutMs: normalized.timeoutMs ?? 8000,
        searchAllFrames: normalized.searchAllFrames ?? true,
      });
    }

    const preview = await chosen.evaluate(el => el.outerHTML?.slice(0, 80)).catch(() => '<locator>');
    return `clicked ${preview}`;
  }




  async get_dom(
    { limit = 100000, exclude = true, focus = [], loadState = 'networkidle', timeout = 10000 } = {},
    agentMemory = {}
  ) {
    // --- 1) Ensure we have a live page ---
    const hasContext = !!this.context;

    // Recover a page if missing/closed
    const recoverPage = async () => {
      if (hasContext) {
        const pages = (this.context.pages?.() || []).filter(p => !p.isClosed?.());
        if (pages.length) {
          // Prefer the last page (often the active one / popup)
          this.page = pages[pages.length - 1];
          return;
        }
        // No pages at all in a live context -> make one
        this.page = await this.context.newPage();
        return;
      }
      // No context yet but a browser exists -> create context + page
      if (this.browser?.newContext) {
        this.context = await this.browser.newContext();
        this.page = await this.context.newPage();
        return;
      }
      throw new Error('No browser context/page available in get_dom().');
    };

    if (!this.page || this.page.isClosed?.()) {
      await recoverPage();
    }

    // --- 2) Try to reach a usable load state (best-effort) ---
    try {
      await this.page.waitForLoadState(loadState, { timeout });
    } catch {
      // Non-fatal: some apps never reach 'load', we’ll still try to read the DOM.
    }

    // If navigation changed active page (e.g., popup), reselect a live page
    try {
      const pages = this.context?.pages?.() || [];
      if (pages.length && (this.page.isClosed?.() || !pages.includes(this.page))) {
        this.page = pages[pages.length - 1];
      }
    } catch { /* ignore */ }

    // --- 3) Get HTML content with a small retry on failure ---
    let html = '';
    for (let attempt = 0; attempt < 2; attempt++) {
      try {
        html = await this.page.content();
        if (html && html.trim()) break;
      } catch (err) {
        // First failure: try waiting for network to settle, then retry
        if (attempt === 0) {
          try { await this.page.waitForLoadState('networkidle', { timeout: 5000 }); } catch {}
          // Also re-check active page (popups can swap)
          try {
            const pages = this.context?.pages?.() || [];
            if (pages.length) this.page = pages[pages.length - 1];
          } catch {}
        } else {
          // Second failure: bubble up a clearer message
          throw new Error(`get_dom() failed to read page content: ${err?.message || err}`);
        }
      }
    }

    // Fallback to empty string if still nothing (keeps caller logic simple)
    if (!html) html = '';

    // --- 4) Optional DOM reduction/cleanup (your existing steps) ---
    let $ = cheerio.load(html);

    if (exclude) {
      $ = await removeNonContentTags($);
      $ = await reduceRepeatedDivs($);
      // If you later re-enable:
      // $ = await removeObfuscatedClassNames($);
      // $ = await removeAutoGeneratedClasses($);
    }

    // (Optional: If you'd like to use `focus`, you could filter here by selectors/keywords.)

    // --- 5) Return trimmed HTML ---
    const finalHtml = $.html();
    return finalHtml.slice(0, limit);
  }

  
  async check_text({ text }) {
    const html = await this.page.content();
    return html.includes(text) ? `FOUND: ${text}` : `NOT FOUND: ${text}`;
  }

  async click_text({ text }) {
    console.log("attempting to click text with normal click:", text);

    const elements = await this.page.$$('button, a, span, div, li, p'); // expand as needed
    for (const el of elements) {
      const innerText = await el.innerText().catch(() => '');
      if (innerText.includes(text)) {
        await el.scrollIntoViewIfNeeded().catch(() => {});
        await el.click();
        await this.page.waitForTimeout(5000);
        return `clicked text "${text}"`;
        
      }
    }
    throw new Error(`Element with text "${text}" not found`);
  }

  async click_text_xpath({ text, delayMs = 1000 }) {
    console.log("attempting to click text using XPath:", text);
    const candidates = await this.page.$x(`//*[normalize-space(text())="${text}"]`);
    for (const el of candidates) {
      const visible = await el.isVisible?.() ?? await this.page.evaluate(el => {
        const rect = el.getBoundingClientRect();
        return (
          rect.width > 0 &&
          rect.height > 0 &&
          window.getComputedStyle(el).visibility !== 'hidden' &&
          window.getComputedStyle(el).display !== 'none'
        );
      }, el);
  
      if (visible) {
        const box = await el.boundingBox();
        console.log(`[click_text] → Clicking visible element with bounding box`, box);
        await el.click();
        await this.page.waitForTimeout(delayMs);
        return `clicked visible text "${text}"`;
      }
    }
  
    throw new Error(`Text "${text}" not found or not visible`);
  }
  

  async click_and_follow_popup({ selector, expectedUrlHost, timeoutMs = 20_000 }) {
    const cur = this._getCurrent(); // { id, page }
    await cur.page.waitForSelector(selector, { timeout: 30_000 });

    // Two possibilities:
    // 1) Popup opens (context 'page' event)
    // 2) Same-tab navigation (no popup)
    const waitPopup = this.context.waitForEvent('page', { timeout: timeoutMs }).catch(() => null);
    const waitNav   = cur.page.waitForNavigation({ timeout: timeoutMs }).catch(() => null);

    // Trigger the click; whichever event resolves first will "win"
    await Promise.allSettled([
      (async () => { await cur.page.click(selector); })(),
    ]);

    const result = await Promise.race([waitPopup, waitNav]);

    // Popup case: result is a Page (has .url() function)
    if (result && typeof result.url === 'function') {
      const popup = result;
      await popup.waitForLoadState('domcontentloaded', { timeout: timeoutMs }).catch(() => {});
      if (expectedUrlHost) {
        try {
          await popup.waitForURL(u => new URL(u).host.includes(expectedUrlHost), { timeout: timeoutMs });
        } catch {/* best-effort only */}
      }
      const id = this._addAndFocus(popup);
      return { ok: true, pageId: id, url: popup.url(), note: 'Switched to popup' };
    }

    // Same-tab case: stay on current page but ensure DOM is ready
    await cur.page.waitForLoadState('domcontentloaded', { timeout: timeoutMs }).catch(() => {});
    return { ok: true, pageId: this.currentId, url: cur.page.url(), note: 'No popup; same tab' };
  }

  async switch_to_page({ target }) {
    const id = this._switchTo(target);  // 'main' | 'latest' | explicit id
    const cur = this._getCurrent();
    return { ok: true, pageId: id, url: cur.page.url() };
  }

  async close_current_page() {
    const cur = this._getCurrent();
    const closingId = cur.id;
    await cur.page.close().catch(() => {});

    this.pages = this.pages.filter(p => p.id !== closingId);
    // choose a new current (latest, or main)
    this.currentId = this.pages[this.pages.length - 1]?.id ?? this.pages[0]?.id ?? '';
    this.page = this._getCurrent()?.page ?? null;

    if (!this.currentId) return { ok: true, note: 'Closed last page; no pages remain' };
    return { ok: true, pageId: this.currentId, note: 'Closed page and switched to another open page' };
  }


  // async get_dom_focus_hint({ prompt }) {
  //   const lower = prompt.toLowerCase();
  //   const focus = [];
  
  //   if (lower.includes('logout') || lower.includes('sign out')) {
  //     focus.push('header', 'nav', 'footer');
  //   } else if (lower.includes('login') || lower.includes('sign in')) {
  //     focus.push('main', 'header');
  //   } else if (lower.includes('settings')) {
  //     focus.push('nav', 'aside', 'main');
  //   }
  
  //   return { focus };
  // }

  async expand_menu({ selector, delayMs = 1000 }) {
    await this.page.waitForSelector(selector, { timeout: 30_000 });
    await this.page.click(selector);
    await this.page.waitForTimeout(delayMs);
    return `expanded menu using ${selector}`;
  }

  async screenshot({ name = 'screenshot' }) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const screenshotPath = `missions/mission_reports/screenshots/${name}_${timestamp}.png`;
  
    await this.page.screenshot({ path: screenshotPath });
  
    // ✅ Return relative path for HTML report
    return `Screenshot saved at: ./screenshots/${name}_${timestamp}.png`;
  }
  
  async upload_file({ selector, fileName, useChooser = false, timeoutMs = 15000 }) {
    if (!selector) throw new Error('upload_file: selector is required');
    if (!fileName) throw new Error('upload_file: fileName is required');

    ensureDir(FILES_DIR);
    const filePath = path.resolve(FILES_DIR, fileName);
    if (!fs.existsSync(filePath)) {
      throw new Error(`upload_file: file not found at ${filePath}`);
    }

    await this.page.waitForSelector(selector, { timeout: timeoutMs });

    let method = 'input';
    if (useChooser) {
      method = 'chooser';
      const [fileChooser] = await Promise.all([
        this.page.waitForEvent('filechooser', { timeout: timeoutMs }),
        this.page.click(selector, { timeout: timeoutMs })
      ]);
      await fileChooser.setFiles(filePath);
    } else {
      const input = this.page.locator(selector).first();
      await input.waitFor({ state: 'visible', timeout: timeoutMs }).catch(() => {});
      await input.setInputFiles(filePath, { timeout: timeoutMs });
    }

    const stats = fs.statSync(filePath);
    const payload = {
      _testronaut_file_event: 'upload',
      method,                       // 'input' | 'chooser'
      fileName,
      sourcePath: filePath,
      bytes: stats.size,
      selector,
      ts: new Date().toISOString()
    };

    appendFileEvent(payload);
    return JSON.stringify(payload);
  }


  async download_file({ selector, url, fileName, timeoutMs = 30000 }) {
    ensureDir(FILES_DIR);

    if (!selector && !url) {
      throw new Error('download_file: provide either selector or url');
    }

    const sanitize = (name) => name.replace(/[\\/:*?"<>|]+/g, '_').trim();

    // Mode 1: page click triggers a browser download
    if (selector) {
      await this.page.waitForSelector(selector, { timeout: timeoutMs });

      const [download] = await Promise.all([
        this.page.waitForEvent('download', { timeout: timeoutMs }),
        this.page.click(selector)
      ]);

      const suggested = sanitize(download.suggestedFilename?.() || 'download.bin');
      const targetPath = path.join(FILES_DIR, sanitize(fileName || suggested));
      await download.saveAs(targetPath);

      const stats = fs.statSync(targetPath);
      const payload = {
        _testronaut_file_event: 'download',
        mode: 'click',
        fileName: path.basename(targetPath),
        destPath: targetPath,
        bytes: stats.size,
        selector,
        url: null,
        ts: new Date().toISOString()
      };

      appendFileEvent(payload);
      return JSON.stringify(payload);
    }

    // Mode 2: direct URL fetch (no page interaction)
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error(`download_file: GET ${url} failed with ${res.status}`);
    }

    // Try to infer a filename if not provided
    const cd = res.headers.get('content-disposition') || '';
    let inferred = 'download.bin';
    const match = /filename\*=UTF-8''([^;]+)|filename="([^"]+)"/i.exec(cd);
    if (match) {
      inferred = decodeURIComponent(match[1] || match[2]);
    } else {
      try {
        const u = new URL(url);
        const tail = u.pathname.split('/').filter(Boolean).pop();
        if (tail) inferred = tail;
      } catch {}
    }

    const targetPath = path.join(FILES_DIR, sanitize(fileName || inferred));
    const buf = Buffer.from(await res.arrayBuffer());
    fs.writeFileSync(targetPath, buf);

    const stats = fs.statSync(targetPath);
    const payload = {
      _testronaut_file_event: 'download',
      mode: 'url',
      fileName: path.basename(targetPath),
      destPath: targetPath,
      bytes: stats.size,
      selector: null,
      url,
      ts: new Date().toISOString()
    };

    appendFileEvent(payload);
    return JSON.stringify(payload);
  }


  async close() {
    await this.browser?.close();
  }
}

export const CHROME_TOOL_MAP = {
  navigate: (b, args) => b.navigate(args),
  fill: (b, args) => b.fill(args),
  click: (b, args) => b.click(args),
  get_dom: (b, args, agentMemory) => b.get_dom(args, agentMemory),
  check_text: (b, args) => b.check_text(args),
  click_text: async (browser, args, agentMemory) => {
    console.log(`[click_text] selecting click type: lastMenuExpanded=${agentMemory.lastMenuExpanded}`);
    if (agentMemory.lastMenuExpanded) {
      return await browser.click_text_xpath(args);
    } else {
      return await browser.click_text(args);
    }
  },
  expand_menu: (b, args) => b.expand_menu(args),
  screenshot: (b, args) => b.screenshot(args),
  click_and_follow_popup: (b, args) => b.click_and_follow_popup(args),
  switch_to_page: (b, args) => b.switch_to_page(args),
  close_current_page: (b, args) => b.close_current_page(args),
  upload_file: (b, args) => b.upload_file(args),
  download_file: (b, args) => b.download_file(args),
};