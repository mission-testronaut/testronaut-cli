import { chromium } from 'playwright';
import * as cheerio from 'cheerio';
import { 
  chunkBySection, 
  reduceRepeatedDivs, 
  removeAutoGeneratedClasses, 
  removeNonContentTags,
  removeObfuscatedClassNames, 
} from './domControl.js';
import fs from 'fs';

export class ChromeBrowser {
  constructor() {
    this.browser = null;
    this.page = null;
  }

  async start() {
    this.browser = await chromium.launch({ headless: true });
    const context = await this.browser.newContext();
    this.page = await context.newPage();
  }

  async navigate({ url }) {
    await this.page.goto(url, { timeout: 30_000 });
    return `navigated to ${this.page.url()}`;
  }

  async fill({ selector, text }) {
    await this.page.waitForSelector(selector, { timeout: 30_000 });
    await this.page.fill(selector, text);
    return `filled ${selector}`;
  }

  async click({ selector, waitFor = 'domcontentloaded', delayMs = 2000 }) {
    await this.page.waitForSelector(selector, { timeout: 30_000 });

    const [res] = await Promise.all([
      this.page.waitForLoadState(waitFor, { timeout: 10_000 }).catch(() => null),
      this.page.click(selector),
    ]);

    if (delayMs) {
      await this.page.waitForTimeout(delayMs);
    }

    return `clicked ${selector} and waited ${delayMs}ms`;
  }

  async get_dom({ limit = 100000, exclude = true, focus = [] }, agentMemory = {}) {
    let html;
    try {
      html = await this.page.content();
    } catch (err) {
      console.warn('âš ï¸ get_dom retrying due to navigation:', err.message);
      // Wait for navigation to settle
      await this.page.waitForLoadState('networkidle', { timeout: 5000 }).catch(() => {});
      html = await this.page.content();
    }
    let $ = cheerio.load(html);
    
    // Remove non-content tags
    if (exclude) {
      $ = await removeNonContentTags($);
      // console.log('ðŸ”§ Non-content tags removed from DOM.');
      $ = await reduceRepeatedDivs($);
      // console.log('ðŸ”§ Repeated divs reduced in DOM.');
      // $ = await removeObfuscatedClassNames($);
      // console.log('ðŸ”§ Obfuscated class names removed from DOM.')
      // $ = await removeAutoGeneratedClasses($);
      // console.log('ðŸ”§ Auto-generated classes removed from DOM.');
    }
    // console.log('ðŸ”§ DOM cleaned up:', $);
    const finalHtml = $.html();
    const trimmed = finalHtml.slice(0, limit);
    return trimmed; 
  }
  
  async check_text({ text }) {
    const html = await this.page.content();
    return html.includes(text) ? `FOUND: ${text}` : `NOT FOUND: ${text}`;
  }

  async click_text({ text }) {
    console.log("attempting to click text with normal click:", text);

    const elements = await this.page.$$('button, a, span, div, li, p'); // expand as needed
    for (const el of elements) {
      const innerText = await el.innerText().catch(() => '');
      if (innerText.includes(text)) {
        await el.scrollIntoViewIfNeeded().catch(() => {});
        await el.click();
        await this.page.waitForTimeout(5000);
        return `clicked text "${text}"`;
        
      }
    }
    throw new Error(`Element with text "${text}" not found`);
  }

  async click_text_xpath({ text, delayMs = 1000 }) {
    console.log("attempting to click text using XPath:", text);
    const candidates = await this.page.$x(`//*[normalize-space(text())="${text}"]`);
    for (const el of candidates) {
      const visible = await el.isVisible?.() ?? await this.page.evaluate(el => {
        const rect = el.getBoundingClientRect();
        return (
          rect.width > 0 &&
          rect.height > 0 &&
          window.getComputedStyle(el).visibility !== 'hidden' &&
          window.getComputedStyle(el).display !== 'none'
        );
      }, el);
  
      if (visible) {
        const box = await el.boundingBox();
        console.log(`[click_text] â†’ Clicking visible element with bounding box`, box);
        await el.click();
        await this.page.waitForTimeout(delayMs);
        return `clicked visible text "${text}"`;
      }
    }
  
    throw new Error(`Text "${text}" not found or not visible`);
  }
  

  // async get_dom_focus_hint({ prompt }) {
  //   const lower = prompt.toLowerCase();
  //   const focus = [];
  
  //   if (lower.includes('logout') || lower.includes('sign out')) {
  //     focus.push('header', 'nav', 'footer');
  //   } else if (lower.includes('login') || lower.includes('sign in')) {
  //     focus.push('main', 'header');
  //   } else if (lower.includes('settings')) {
  //     focus.push('nav', 'aside', 'main');
  //   }
  
  //   return { focus };
  // }

  async expand_menu({ selector, delayMs = 1000 }) {
    await this.page.waitForSelector(selector, { timeout: 30_000 });
    await this.page.click(selector);
    await this.page.waitForTimeout(delayMs);
    return `expanded menu using ${selector}`;
  }

  async screenshot({ name = 'screenshot' }) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const screenshotPath = `missions/mission_reports/screenshots/${name}_${timestamp}.png`;
  
    await this.page.screenshot({ path: screenshotPath });
  
    // âœ… Return relative path for HTML report
    return `Screenshot saved at: ./screenshots/${name}_${timestamp}.png`;
  }
  
  
  async close() {
    await this.browser?.close();
  }
}

export const CHROME_TOOL_MAP = {
  navigate: (b, args) => b.navigate(args),
  fill: (b, args) => b.fill(args),
  click: (b, args) => b.click(args),
  get_dom: (b, args, agentMemory) => b.get_dom(args, agentMemory),
  check_text: (b, args) => b.check_text(args),
  click_text: async (browser, args, agentMemory) => {
    console.log(`[click_text] selecting click type: lastMenuExpanded=${agentMemory.lastMenuExpanded}`);
    if (agentMemory.lastMenuExpanded) {
      return await browser.click_text_xpath(args);
    } else {
      return await browser.click_text(args);
    }
  },
  expand_menu: (b, args) => b.expand_menu(args),
  screenshot: (b, args) => b.screenshot(args),
};