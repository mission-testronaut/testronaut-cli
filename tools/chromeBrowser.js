// Keep browsers in project-local cache; matches ensureBrowsers()
process.env.PLAYWRIGHT_BROWSERS_PATH = process.env.PLAYWRIGHT_BROWSERS_PATH || '0';

// import { chromium } from 'playwright';
import { createRequire } from 'module';
const req = createRequire(process.cwd() + '/noop.js'); // resolve from user project
async function loadPlaywright() {
  try { return req('playwright'); } catch {}
  try { return req('@playwright/test'); } catch {}
  try { return req('playwright-core'); } catch {}
  throw new Error('Playwright is not installed in this project. Run: npm i -D @playwright/test');
}
import * as cheerio from 'cheerio';
import { 
  chunkBySection, 
  reduceRepeatedDivs, 
  removeAutoGeneratedClasses, 
  removeNonContentTags,
  removeObfuscatedClassNames, 
} from './domControl.js';
import fs from 'fs';
import { ensureBrowsers } from '../tools/playwrightSetup.js';

export class ChromeBrowser {
  constructor() {
    this.browser = null;
    this.context = null;
    this.page = null;

    // simple registry
    this.pages = [];      // [{ id, page }]
    this.currentId = '';  // page id we currently control
  }

  _makePageId(page) {
    // playwright's Page has a non-public guid in TS; fallback to random
    return `p_${Math.random().toString(36).slice(2)}`;
  }
  _getCurrent() {
    const cur = this.pages.find(p => p.id === this.currentId) ?? this.pages[this.pages.length - 1];
    if (!cur) throw new Error('No active page in registry');
    return cur;
  }
  _addAndFocus(page) {
    const id = this._makePageId(page);
    this.pages.push({ id, page });
    this.currentId = id;
    this.page = page;

    page.on('close', () => {
      // remove from registry
      this.pages = this.pages.filter(p => p.id !== id);
      // if we just lost the active page, pick a reasonable fallback
      if (this.currentId === id) {
        this.currentId = this.pages[this.pages.length - 1]?.id
                      ?? this.pages[0]?.id
                      ?? '';
        this.page = this.currentId
          ? this.pages.find(p => p.id === this.currentId).page
          : null;
      }
    });

    return id;
  }

  _switchTo(target) {
    if (target === 'main') {
      this.currentId = this.pages[0]?.id ?? '';
    } else if (target === 'latest') {
      this.currentId = this.pages[this.pages.length - 1]?.id ?? '';
    } else {
      const found = this.pages.find(p => p.id === target);
      if (!found) throw new Error(`No page with id "${target}"`);
      this.currentId = found.id;
    }
    const cur = this._getCurrent();
    this.page = cur.page; // keep legacy this.page in sync
    return this.currentId;
  }

  async start() {
    try {
      const pw = await loadPlaywright();
      this.browser = await pw.chromium.launch({ headless: true });    
    } catch (err) {
      const msg = String(err?.message || err);
      const needsInstall =
        msg.includes('Executable doesn\'t exist') ||
        msg.includes('was just installed or updated') ||
        msg.includes('looks like Playwright') ||
        msg.includes('browserType.launch');

      if (!needsInstall) throw err;

      // Download the right browsers and retry once
      console.log('ðŸ§© Playwright browsers missing or stale. Installingâ€¦');
      await ensureBrowsers({ browser: 'chromium', withDeps: true });

      // Retry
      const pw = await loadPlaywright();
      return await pw.chromium.launch({ headless: true });
    }
    this.context = await this.browser.newContext();
    const first = await this.context.newPage();
    const id = this._addAndFocus(first);

    // optional: keep registry in sync if pages are closed elsewhere
    this.context.on('close', () => { this.pages = []; this.currentId = ''; });
    first.on('close', () => {
      this.pages = this.pages.filter(p => p.id !== id);
      if (this.currentId === id) {
        this.currentId = this.pages[this.pages.length - 1]?.id ?? this.pages[0]?.id ?? '';
        this.page = this._getCurrent()?.page ?? null;
      }
    });
  }

  async navigate({ url }) {
    await this.page.goto(url, { timeout: 30_000 });
    return `navigated to ${this.page.url()}`;
  }

  async fill({ selector, text }) {
    await this.page.waitForSelector(selector, { timeout: 30_000 });
    await this.page.fill(selector, text);
    return `filled ${selector}`;
  }

  async click({ selector, waitFor = 'domcontentloaded', delayMs = 2000 }) {
    await this.page.waitForSelector(selector, { timeout: 30_000 });

    const [res] = await Promise.all([
      this.page.waitForLoadState(waitFor, { timeout: 10_000 }).catch(() => null),
      this.page.click(selector),
    ]);

    if (delayMs) {
      await this.page.waitForTimeout(delayMs);
    }

    return `clicked ${selector} and waited ${delayMs}ms`;
  }

  async get_dom({ limit = 100000, exclude = true, focus = [] }, agentMemory = {}) {
    let html;
    try {
      html = await this.page.content();
    } catch (err) {
      console.warn('âš ï¸ get_dom retrying due to navigation:', err.message);
      // Wait for navigation to settle
      await this.page.waitForLoadState('networkidle', { timeout: 5000 }).catch(() => {});
      html = await this.page.content();
    }
    let $ = cheerio.load(html);
    
    // Remove non-content tags
    if (exclude) {
      $ = await removeNonContentTags($);
      // console.log('ðŸ”§ Non-content tags removed from DOM.');
      $ = await reduceRepeatedDivs($);
      // console.log('ðŸ”§ Repeated divs reduced in DOM.');
      // $ = await removeObfuscatedClassNames($);
      // console.log('ðŸ”§ Obfuscated class names removed from DOM.')
      // $ = await removeAutoGeneratedClasses($);
      // console.log('ðŸ”§ Auto-generated classes removed from DOM.');
    }
    // console.log('ðŸ”§ DOM cleaned up:', $);
    const finalHtml = $.html();
    const trimmed = finalHtml.slice(0, limit);
    return trimmed; 
  }
  
  async check_text({ text }) {
    const html = await this.page.content();
    return html.includes(text) ? `FOUND: ${text}` : `NOT FOUND: ${text}`;
  }

  async click_text({ text }) {
    console.log("attempting to click text with normal click:", text);

    const elements = await this.page.$$('button, a, span, div, li, p'); // expand as needed
    for (const el of elements) {
      const innerText = await el.innerText().catch(() => '');
      if (innerText.includes(text)) {
        await el.scrollIntoViewIfNeeded().catch(() => {});
        await el.click();
        await this.page.waitForTimeout(5000);
        return `clicked text "${text}"`;
        
      }
    }
    throw new Error(`Element with text "${text}" not found`);
  }

  async click_text_xpath({ text, delayMs = 1000 }) {
    console.log("attempting to click text using XPath:", text);
    const candidates = await this.page.$x(`//*[normalize-space(text())="${text}"]`);
    for (const el of candidates) {
      const visible = await el.isVisible?.() ?? await this.page.evaluate(el => {
        const rect = el.getBoundingClientRect();
        return (
          rect.width > 0 &&
          rect.height > 0 &&
          window.getComputedStyle(el).visibility !== 'hidden' &&
          window.getComputedStyle(el).display !== 'none'
        );
      }, el);
  
      if (visible) {
        const box = await el.boundingBox();
        console.log(`[click_text] â†’ Clicking visible element with bounding box`, box);
        await el.click();
        await this.page.waitForTimeout(delayMs);
        return `clicked visible text "${text}"`;
      }
    }
  
    throw new Error(`Text "${text}" not found or not visible`);
  }
  

  async click_and_follow_popup({ selector, expectedUrlHost, timeoutMs = 20_000 }) {
    const cur = this._getCurrent(); // { id, page }
    await cur.page.waitForSelector(selector, { timeout: 30_000 });

    // Two possibilities:
    // 1) Popup opens (context 'page' event)
    // 2) Same-tab navigation (no popup)
    const waitPopup = this.context.waitForEvent('page', { timeout: timeoutMs }).catch(() => null);
    const waitNav   = cur.page.waitForNavigation({ timeout: timeoutMs }).catch(() => null);

    // Trigger the click; whichever event resolves first will "win"
    await Promise.allSettled([
      (async () => { await cur.page.click(selector); })(),
    ]);

    const result = await Promise.race([waitPopup, waitNav]);

    // Popup case: result is a Page (has .url() function)
    if (result && typeof result.url === 'function') {
      const popup = result;
      await popup.waitForLoadState('domcontentloaded', { timeout: timeoutMs }).catch(() => {});
      if (expectedUrlHost) {
        try {
          await popup.waitForURL(u => new URL(u).host.includes(expectedUrlHost), { timeout: timeoutMs });
        } catch {/* best-effort only */}
      }
      const id = this._addAndFocus(popup);
      return { ok: true, pageId: id, url: popup.url(), note: 'Switched to popup' };
    }

    // Same-tab case: stay on current page but ensure DOM is ready
    await cur.page.waitForLoadState('domcontentloaded', { timeout: timeoutMs }).catch(() => {});
    return { ok: true, pageId: this.currentId, url: cur.page.url(), note: 'No popup; same tab' };
  }

  async switch_to_page({ target }) {
    const id = this._switchTo(target);  // 'main' | 'latest' | explicit id
    const cur = this._getCurrent();
    return { ok: true, pageId: id, url: cur.page.url() };
  }

  async close_current_page() {
    const cur = this._getCurrent();
    const closingId = cur.id;
    await cur.page.close().catch(() => {});

    this.pages = this.pages.filter(p => p.id !== closingId);
    // choose a new current (latest, or main)
    this.currentId = this.pages[this.pages.length - 1]?.id ?? this.pages[0]?.id ?? '';
    this.page = this._getCurrent()?.page ?? null;

    if (!this.currentId) return { ok: true, note: 'Closed last page; no pages remain' };
    return { ok: true, pageId: this.currentId, note: 'Closed page and switched to another open page' };
  }


  // async get_dom_focus_hint({ prompt }) {
  //   const lower = prompt.toLowerCase();
  //   const focus = [];
  
  //   if (lower.includes('logout') || lower.includes('sign out')) {
  //     focus.push('header', 'nav', 'footer');
  //   } else if (lower.includes('login') || lower.includes('sign in')) {
  //     focus.push('main', 'header');
  //   } else if (lower.includes('settings')) {
  //     focus.push('nav', 'aside', 'main');
  //   }
  
  //   return { focus };
  // }

  async expand_menu({ selector, delayMs = 1000 }) {
    await this.page.waitForSelector(selector, { timeout: 30_000 });
    await this.page.click(selector);
    await this.page.waitForTimeout(delayMs);
    return `expanded menu using ${selector}`;
  }

  async screenshot({ name = 'screenshot' }) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const screenshotPath = `missions/mission_reports/screenshots/${name}_${timestamp}.png`;
  
    await this.page.screenshot({ path: screenshotPath });
  
    // âœ… Return relative path for HTML report
    return `Screenshot saved at: ./screenshots/${name}_${timestamp}.png`;
  }
  
  
  async close() {
    await this.browser?.close();
  }
}

export const CHROME_TOOL_MAP = {
  navigate: (b, args) => b.navigate(args),
  fill: (b, args) => b.fill(args),
  click: (b, args) => b.click(args),
  get_dom: (b, args, agentMemory) => b.get_dom(args, agentMemory),
  check_text: (b, args) => b.check_text(args),
  click_text: async (browser, args, agentMemory) => {
    console.log(`[click_text] selecting click type: lastMenuExpanded=${agentMemory.lastMenuExpanded}`);
    if (agentMemory.lastMenuExpanded) {
      return await browser.click_text_xpath(args);
    } else {
      return await browser.click_text(args);
    }
  },
  expand_menu: (b, args) => b.expand_menu(args),
  screenshot: (b, args) => b.screenshot(args),
  click_and_follow_popup: (b, args) => b.click_and_follow_popup(args),
  switch_to_page: (b, args) => b.switch_to_page(args),
  close_current_page: (b, args) => b.close_current_page(args),
};