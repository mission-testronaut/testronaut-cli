export const removeNonContentTags = async ($) => {
  $('script, style, meta, link, noscript, iframe, canvas, svg').remove();
  
  $('*').each((_, el) => {
    const $el = $(el);
    const allowedAttrs = [
      'href', 'src', 'type', 'alt', 'title',
      'placeholder', 'name', 'id', 'class', 'aria-label', 'value'
    ];

    const attrs = el.attribs;
    // const tagName = $el.get(0)?.tagName?.toLowerCase();
    // const keepEmpty = ['input', 'button', 'textarea', 'select'];

    // if (!keepEmpty.includes(tagName) && !$el.text().trim() && $el.children().length === 0) {
    //   $el.remove();
    // }

    for (const attr in attrs) {
      if (!allowedAttrs.includes(attr)) {
        $el.removeAttr(attr);
      }
    }
  });

  $('*')
    .contents()
    .each(function () {
      if (this.type === 'comment') {
        $(this).remove();
      }
    });

  return $;
}

export const collapseLongContent = async ($, limit = 10) => {
  $('ul, ol').each((_, el) => {
    const $el = $(el);
    const items = $el.children('li');

    if (items.length > limit) {
      items.slice(limit).remove();
      $el.append('<li data-collapsed="true">[...truncated]</li>');
    }
  });

  $('div, section').each((_, el) => {
    const $el = $(el);
    const children = $el.children();

    if (children.length > limit) {
      children.slice(limit).remove();
      $el.append('<div data-collapsed="true">[...truncated]</div>');
    }
  });
}

export const chunkBySection = async ($, focus) => {
  const chunks = {
    header: $('header').html() || '',
    nav: $('nav').html() || '',
    main: $('main').html() || '',
    footer: $('footer').html() || '',
    aside: $('aside').html() || '',
    body: $('body').html() || ''
  };

  if (Array.isArray(focus) && focus.length > 0) {
    return Object.fromEntries(
      Object.entries(chunks).filter(
        ([k]) => focus.includes(k)
      )
    );
  }

  return chunks;

  // let focusedChunks = Object.entries(chunks)
  //   .filter(([key]) => focus?.length === 0 || focus?.includes(key))
  //   .map(([, html]) => html)
  //   .join('\n');

  // return focusedChunks;

}

export function reduceRepeatedDivs($, maxAllowed = 3) {
  $('body, div').each((_, parentEl) => {
    const $parent = $(parentEl);
    const children = $parent.children('div');

    // Group children divs by class name
    const classGroups = {};
    children.each((_, child) => {
      const $child = $(child);
      const className = $child.attr('class');
      if (!className) return;
      
      if (!classGroups[className]) {
        classGroups[className] = [];
      }
      classGroups[className].push(child);
    });

    // Reduce each group to maxAllowed
    for (const className in classGroups) {
      const group = classGroups[className];
      if (group.length > maxAllowed) {
        // Remove excess nodes from the DOM
        group.slice(maxAllowed).forEach(el => $(el).remove());
        $parent.append(`<div data-collapsed="true" data-class="${className}">[...truncated]</div>`);
      }
    }
  });
  return $;
}

/**
 * Remove obfuscated or hashed class names from a DOM string.
 * Criteria: class names with high entropy (random letters/numbers), or very short length
 */
export function removeObfuscatedClassNames($) {
  $('[class]').each((_, el) => {
    const $el = $(el);
    const originalClasses = ($el.attr('class') || '').split(/\s+/);
    const filtered = originalClasses.filter(cls => {
      const isShort = cls.length <= 2;
      const isHashed = /^[a-z0-9_-]{6,}$/.test(cls) && /[0-9]/.test(cls);
      const isObviousHash = /^[A-Za-z0-9_-]{6,}$/.test(cls) && /[A-Z]/.test(cls) && /[0-9]/.test(cls);
      return !(isShort || isHashed || isObviousHash);
    });
    if (filtered.length) {
      $el.attr('class', filtered.join(' '));
    } else {
      $el.removeAttr('class');
    }
  });

  return $;
}

/**
 * Remove known auto-generated or utility classes (e.g., Tailwind/MUI/CSS-in-JS)
 */
export function removeAutoGeneratedClasses($) {
  // Regex patterns for utility classes, internal prefixes, and other noise
  const utilityClassPatterns = [
    /^text-/, /^bg-/, /^p[trblxy]?-\d+/, /^m[trblxy]?-\d+/, /^w-/, /^h-/, /^rounded/, /^border/, /^hover:/,
    /^focus:/, /^group/, /^peer/, /^ring/, /^cl-/, /^md:/, /^sm:/, /^lg:/, /^xl:/, /^2xl:/, /^z-\d+/,
    /^translate/, /^flex/, /^grid/, /^justify-/, /^items-/, /^gap-/, /^shadow/, /^overflow/, /^truncate/,
    /^relative$/, /^absolute$/, /^inset/, /^top/, /^bottom/, /^left/, /^right/,
    /^opacity-/, /^transition/, /^duration-/, /^ease-/, /^cursor-/, /^select-/, /^pointer-events-/,
  ];

  $('[class]').each((_, el) => {
    const $el = $(el);
    const classes = ($el.attr('class') || '').split(/\s+/);
    const filtered = classes.filter(cls => {
      return !utilityClassPatterns.some(pattern => pattern.test(cls));
    });
    if (filtered.length) {
      $el.attr('class', filtered.join(' '));
    } else {
      $el.removeAttr('class');
    }
  });

  return $;
}
